### this 全面解析
####2.1 调用位置
在理解this的绑定过程之前，首先要理解`调用位置`。调用位置就是函数在代码中被调用的位置，而不是声明的位置。只有仔细分析调用位置才能回答这个问题，这个this到底引用什么？
通常来说，寻找调用位置，就是寻找`函数被调用的位置`，但是做起来并没有那么简单，因为某些编程模式可能会隐藏真正的调用位置。
最重要的是要分析`调用栈`(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。
下面我们来看看到底什么是调用栈和调用位置：
<pre>
function baz () {
	//当前调用栈是baz
	//因此，当前调用位置是全局作用域
	console.log("baz");
	bar();//bar 的调用位置
}

function bar () {
//当前调用栈是baz-》bar
//因此，当前调用位置在baz中
console.log("bar");
foo();
}
function foo(){
//当前调用栈是baz-》bar-》foo
//因此当前调用位置在bar中
console.log("foo");
}
baz();//<---baz的调用位置
</pre>

注意我们是如何分析出真正的调用位置的，因为它决定了this得绑定。
> 你可以把调用栈想象成一个函数调用链，就像我们在前面代码段的注释中所写的一样。但是这种方法非常麻烦并且容易出错。另一个查看调用栈的方法是使用浏览器的调试工具。绝大多数现代桌面浏览器都内置了开发者工具，其中包含javascript调试器。就本例来说，你可以在工具中给foo函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条debugger语句。运行代码是，调试器会在那个位置暂停，同时会展示当前函数调用列表，这就是你的调用栈。因此，如果你想要分析this的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。

####2.2 绑定规则
我们来看看在函数的执行过程中调用位置如何决定this的绑定对象。
你必须找到调用位置，然后判断需要应用下面四条规则中得哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时他们的优先级如何排列。
##### 2.2.1 默认绑定
首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时默认规则。
思考一下下面的代码：
<pre>
function foo () {
	console.log( this. a);
}
var a = 2;
foo(); // a
</pre>
你应该注意到的第一件事是，声明在全局作用域中得变量，比如 var a = 2，就是全局对象的一个同名属性。他们本质上就是同一个东西，并不是通过复制得到的，就像一个硬币的两面一样。
接下来我们可以看到当调用foo()时，`this.a`被解析成了全局变量a。为什么？因为在本例中，函数调用时应用了`this`的默认绑定，因此`this`指向全局对象。
那么我们怎么知道这里应用了`默认绑定`呢？